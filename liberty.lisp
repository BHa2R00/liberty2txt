(defparameter *liberty-txt* "")
(defparameter *liberty-timing* t)
(defparameter *liberty-power* t)
(defun liberty-compiler (file)
  (if (probe-file file)
	(let ((txt *liberty-txt*)
		  (b "")
		  ;(r "")
		  (v "")
		  (wc ""))
	  (format t "read liberty ~A~%" file)
	  (setf wc (with-output-to-string (s) (exec s "wc" "-l" file)))
	  (setf wc (sym+(pscan "[0-9]+" wc)))
	  ;(format t "~S~%" wc)
  (with-fp-w 
	fo txt 
  (with-fp-r
	f file
	(do ((k 1 (+ k 1))
		 (line (read-line f nil 'end) (read-line f nil 'end)))
	  ((equalp line 'end))
	  (if (pscan "\\S+" line)
		(let ((line1 (preplace "\\s+" line "")))
		  (cond
			((pscan "^library[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (format fo "~A" line2);(format fo "(setf *from-liberty* (string+ *from-liberty* ~S))~%" line2);(setf r (string+ line2))
			   ))
			((pscan "^(operating_conditions|compact_lut_template|lu_table_template|power_lut_template)[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (format fo "~A" (string+ #\Newline line2));(format fo "(setf *from-liberty* (string+ *from-liberty* ~S))~%" (string+ #\Newline line2));(setf r (string+ r #\Newline line2))
			   ))
			((pscan "^cell[\\(]{1}" line1) 
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (pscan "\\S+" b) 
				 (let ()
				   (format fo "~A" (string+ #\Newline b));(format fo "(setf *from-liberty* (string+ *from-liberty* ~S))~%" (string+ #\Newline b));(setf r (string+ r #\Newline b))
				   (if (pscan "^cell(\\s+)([0-9,a-z,A-Z,_]+)" b)
					 (let ((b1 (pscan "^cell(\\s+)([0-9,a-z,A-Z,_]+)" b)))
					   (map 'list
							(lambda (b2)
							  (setf b1 (string+ b1 b2)))
							(pmatch "(\\s+)(pin|direction|clear|clocked_on|next_state|function|enable|data_in)(\\s+)(\\S+)" b))
					   (format t " ~4f% append ~A ~%" (* 100 (float(/ k wc))) b1)
					   ))
				   ))
			   (setf b line2)
			   ))
			((pscan "^(ff|latch)[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((pscan "^pin[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((pscan "^(cell_footprint|area|clear|clocked_on|next_state|function|enable|data_in|direction|related_pin)[:]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((and *liberty-timing* (pscan "^(timing_type|max_transition|min_pulse_width_high|timing_sense|max_capacitance)[:]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((and *liberty-timing* (pscan "^(compact_ccs_(rise|fall)|(rise|fall)_constraint)[\\(]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((and *liberty-power* (pscan "^(dynamic_current|related_inputs|related_outputs|switching_group|input_switching_condition|output_switching_condition|pg_current|compact_ccs_power|receiver_capacitance([0-9]+)_(rise|fall))[:]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;]+" line2 " "))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((and *liberty-timing* (pscan "^(index_[0-9]+)[\\(]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((and (or *liberty-timing* *liberty-power*) (equalp v "") (pscan "^values" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v line2)
			   ))
			((and (or *liberty-timing* *liberty-power*) (not (equalp v "")) (pscan "^[\"]{1}" line1) (pscan "[\\\\]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v (string+ v line2))
			   ))
			((and (or *liberty-timing* *liberty-power*) (not (equalp v "")) (pscan "^[\"]{1}" line1) (not(pscan "[\\\\]{1}" line1)))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v (string+ v line2))
			   (format fo "~A" (string+ v));(format fo "(setf *from-liberty* (string+ *from-liberty* ~S))~%" (string+ #\Newline v));(setf r (string+ r #\Newline v))
			   (setf v "")
			   ))
			)
		  ))))
	  ;(setf *from-liberty* (string+ *from-liberty* #\Newline r))
	  )
	  ;(compile-file out)
	  ;(load out)
	  txt ;r
	  )
	nil))
(defun get-lib-cells (lib_matcher cell_matcher &rest filters)
  (let ((r "")
		(libon nil))
	(if (probe-file *liberty-txt*)
	(with-fp-r 
	  s *liberty-txt*
	  (do ((line (read-line s nil 'end) (read-line s nil 'end)))
		((equalp line 'end))
		(if (pscan "\\S+" line)
		  (let ((line1 line))
			(cond
			  ((pscan "^library(\\s+)" line1)
			   (let ()
				 (if (pscan (string+"^library(\\s+)"lib_matcher) line1)
				   (setf libon t)
				   (setf libon nil)
				   )
				 ))
			  ((and libon (pscan (string+"^cell(\\s+)"cell_matcher) line1))
			   (let ((check t))
				 (map 'list
					  (lambda (filter)
						(if (and
							  check
							  (not(pscan filter line1))
							  )
						  (setf check nil)))
					  filters)
				 (if check 
				   (let ()
					 (setf r (string+ r #\Newline line1))
					 #|(let ((b1 (pscan "^cell(\\s+)([0-9,a-z,A-Z,_]+)" line1)))
					   (map 'list
							(lambda (b2)
							  (setf b1 (string+ b1 b2)))
							(pmatch "(\\s+)(pin|direction|clear|clocked_on|next_state|function|enable|data_in)(\\s+)(\\S+)" b))
					   )|#
					 ))
				 ))
			  )
			)))))
	r))
(defun lines-match (matcher lines)
  #|(map 'list
	   (lambda (line)
		 (let ((b ""))
		   (map 'list
				(lambda (b1)
				  (setf b (string+ b b1))
				  )
				(pmatch matcher line))
		   b))
	   (psplit "$" lines))|#
  (with-output-to-string (f)
	(with-input-from-string (s lines)
	  (do ((line (read-line s nil 'end) (read-line s nil 'end)))
		((equalp line 'end))
		(if (pscan "\\S+" line)
		  (let ((b ""))
			(map 'list
				 (lambda (b1)
				   (setf b (string+ b b1))
				   )
				 (pmatch matcher line))
			(format f "~%~A" b)))
		))))
