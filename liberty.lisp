(defparameter *search-path* (list))
(defparameter *target-library* (list))
(defparameter *liberty-txt* "a.lib.txt")
(defmacro map-libraries ((path lib file) &body body)
  `(map 'list
		(lambda (,path)
		  (map 'list
			   (lambda (,lib)
				 (let ((,file (string+ ,path"/",lib)))
				   (if (probe-file ,file)
					 (let ()
					   (setf *liberty-txt* ,file)
					   ,@body
					   ))))
			   *target-library*))
		*search-path*))
(defparameter *liberty-timing* t)
(defparameter *liberty-power* t)
(defun read-liberty (file)
  (if (probe-file file)
	(let ((txt *liberty-txt*)
		  (b "")
		  (v "")
		  (wc ""))
	  (format t "read liberty ~A~%" file)
	  (setf wc (with-output-to-string (s) (exec s "wc" "-l" file)))
	  (setf wc (sym+(pscan "[0-9]+" wc)))
  (with-fp-w+ 
	fo txt 
	  (format t "append txt ~A~%" txt)
  (with-fp-r
	f file
	(do ((k 1 (+ k 1))
		 (line (read-line f nil 'end) (read-line f nil 'end)))
	  ((equalp line 'end) (format fo "~%"))
	  (if (pscan "\\S+" line)
		(let ((line1 (preplace "\\s+" line "")))
		  (cond
			((pscan "^library[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (format fo "~A" line2)
			   ))
			((pscan "^(operating_conditions|compact_lut_template|lu_table_template|power_lut_template)[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (format fo "~A" (string+ #\Newline line2))
			   ))
			((pscan "^cell[\\(]{1}" line1) 
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (pscan "\\S+" b) 
				 (let ()
				   (format fo "~A" (string+ #\Newline b))
				   (if (pscan "^cell(\\s+)([0-9,a-z,A-Z,_]+)" b)
					 (let ((b1 (pscan "^cell(\\s+)([0-9,a-z,A-Z,_]+)" b)))
					   (map 'list
							(lambda (b2)
							  (setf b1 (string+ b1 b2)))
							(pmatch "(\\s+)(pin)(\\s+)(\\S+)" b))
					   (format t " ~4f% append ~A ~%" (* 100 (float(/ k wc))) b1)
					   ))
				   ))
			   (setf b line2)
			   ))
			((pscan "^(ff|latch)[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))	
			((pscan "^(clear|clocked_on|next_state|enable|data_in)[:,;]+" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;,\"]+" line2 " "))
			   (setf b (string+ b " " line2))
			   ))
			((pscan "^(cell_footprint|area)[:,;,\"]+" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;,\"]+" line2 " "))
			   (if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((pscan "^pin[\\(]{1}" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (setf b (string+ b " " line2));(if (not(pscan (pquote line2) b)) (setf b (string+ b " " line2)))
			   ))
			((pscan "^(direction|function|related_pin|capacitance)[:,;]+" line1)
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;,\"]+" line2 " "))
			   (setf b (string+ b " " line2))
			   ))
			((and *liberty-timing* (pscan "^(timing_type|max_transition|min_pulse_width_high|timing_sense|max_capacitance)[:]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;]+" line2 " "))
			   (setf b (string+ b " " line2))
			   ))
			((and *liberty-timing* (pscan "^(compact_ccs_(rise|fall)|(rise|fall)_constraint|cell_(rise|fall)|(rise|fall)_transition)[\\(]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (setf b (string+ b " " line2))
			   ))
			((and *liberty-power* (pscan "^(dynamic_current|related_inputs|related_outputs|switching_group|input_switching_condition|output_switching_condition|pg_current|compact_ccs_power|receiver_capacitance([0-9]+)_(rise|fall)|when)[:]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[:,;]+" line2 " "))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\"]+" line2 " "))
			   (setf b (string+ b " " line2))
			   ))
			((and *liberty-timing* (equalp v "") (pscan "^(index_[0-9]+)[\\(]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   ;(setf b (string+ b " " line2))
			   (setf v (string+ v line2))
			   (if (pscan "[;]{1}" line1)
				 (let ()
				   (format fo "~A" (string+ v))
				   (setf v "")
				   ))
			   ))
			((and (or *liberty-timing* *liberty-power*) (equalp v "") (pscan "^values" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v line2)
			   ))
			((and (or *liberty-timing* *liberty-power*) (not (equalp v "")) (pscan "^[\"]{1}" line1) (pscan "[\\\\]{1}" line1))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v (string+ v line2))
			   ))
			((and (or *liberty-timing* *liberty-power*) (not (equalp v "")) (pscan "^[\"]{1}" line1) (not(pscan "[\\\\]{1}" line1)))
			 (let ((line2 line1))
			   (setf line2 (preplace "[\\(,\\),\\{,\\},\",\\,,;,:,\\\\\]+" line2 " "))
			   (setf v (string+ v line2))
			   (format fo "~A" (string+ v))
			   (setf v "")
			   ))
			)
		  ))))
	  )txt)
	(let ()
	  (format t "can not read liberty ~A ~%" file)
	  nil)
	))
(defun get-lib-cells (lib_matcher cell_matcher &rest filters)
  (let ((r "")
		(libon nil))
	(if (probe-file *liberty-txt*)
	(with-fp-r 
	  s *liberty-txt*
	  (do ((line (read-line s nil 'end) (read-line s nil 'end)))
		((equalp line 'end))
		(if (pscan "\\S+" line)
		  (let ((line1 line))
			(cond
			  ((pscan "^library(\\s+)" line1)
			   (let ()
				 (if (pscan (string+"^library(\\s+)"lib_matcher) line1)
				   (setf libon t)
				   (setf libon nil)
				   )
				 ))
			  ((and libon (pscan (string+"^cell(\\s+)"cell_matcher) line1))
			   (let ((check t))
				 (map 'list
					  (lambda (filter)
						(if (and
							  check
							  (not(pscan filter line1))
							  )
						  (setf check nil)))
					  filters)
				 (if check 
				   (let ()
					 (setf r (string+ r #\Newline line1))
					 ))
				 ))
			  )
			))))
	(format t "can not read txt ~A ~%" *liberty-txt*)
	)
	r))
(defun lines-match (matcher lines)
  (with-output-to-string (f)
	(with-input-from-string (s lines)
	  (do ((line (read-line s nil 'end) (read-line s nil 'end)))
		((equalp line 'end))
		(if (pscan "\\S+" line)
		  (let ((b ""))
			(map 'list
				 (lambda (b1)
				   (setf b (string+ b b1))
				   )
				 (pmatch matcher line))
			(format f "~%~A" b)))
		))))
(defun eval-string-expr (e)
  ;(format t "~S~%" e)
  (cond
	((pscan "[\\(]{1}#[1]{1}[\\)]{1}"          e) (eval-string-expr(preplace "[\\(]{1}#[1]{1}[\\)]{1}"          e "#1")))
	((pscan "[\\(]{1}#[0]{1}[\\)]{1}"          e) (eval-string-expr(preplace "[\\(]{1}#[0]{1}[\\)]{1}"          e "#0")))
	((pscan "[\\(]{1}#[x]{1}[\\)]{1}"          e) (eval-string-expr(preplace "[\\(]{1}#[x]{1}[\\)]{1}"          e "#x")))
	((pscan "[\\(]{1}#[z]{1}[\\)]{1}"          e) (eval-string-expr(preplace "[\\(]{1}#[z]{1}[\\)]{1}"          e "#z")))
	((pscan "#[1]{1}[\\']{1}"                  e) (eval-string-expr(preplace "#[1]{1}[\\']{1}"                  e "#0")))
	((pscan "[\\!,\\~]{1}#[1]{1}"              e) (eval-string-expr(preplace "[\\!,\\~]{1}#[1]{1}"              e "#0")))
	((pscan "#[0]{1}[\\']{1}"                  e) (eval-string-expr(preplace "#[0]{1}[\\']{1}"                  e "#1")))
	((pscan "[\\!,\\~]{1}#[0]{1}"              e) (eval-string-expr(preplace "[\\!,\\~]{1}#[0]{1}"              e "#1")))
	((pscan "#[x,z]{1}[\\']{1}"                e) (eval-string-expr(preplace "#[x,z]{1}[\\']{1}"                e "#x")))
	((pscan "[\\!,\\~]{1}#[x,z]{1}"            e) (eval-string-expr(preplace "[\\!,\\~]{1}#[x,z]{1}"            e "#x")))
	((pscan "#[0]{1}[\\+,\\|]{1}#[0]{1}"       e) (eval-string-expr(preplace "#[0]{1}[\\+,\\|]{1}#[0]{1}"       e "#0")))
	((pscan "#[0,x,z]{1}[\\+,\\|]{1}#[1]{1}"   e) (eval-string-expr(preplace "#[0,x,z]{1}[\\+,\\|]{1}#[1]{1}"   e "#1")))
	((pscan "#[1]{1}[\\+,\\|]{1}#[0,x,z]{1}"   e) (eval-string-expr(preplace "#[1]{1}[\\+,\\|]{1}#[0,x,z]{1}"   e "#1")))
	((pscan "#[1]{1}[\\+,\\|]{1}#[1]{1}"       e) (eval-string-expr(preplace "#[1]{1}[\\+,\\|]{1}#[1]{1}"       e "#1")))
	((pscan "#[0]{1}[\\*,\\&]{0,1}#[0]{1}"     e) (eval-string-expr(preplace "#[0]{1}[\\*,\\&]{0,1}#[0]{1}"     e "#0")))
	((pscan "#[0]{1}[\\*,\\&]{0,1}#[1,x,z]{1}" e) (eval-string-expr(preplace "#[0]{1}[\\*,\\&]{0,1}#[1,x,z]{1}" e "#0")))
	((pscan "#[1,x,z]{1}[\\*,\\&]{0,1}#[0]{1}" e) (eval-string-expr(preplace "#[1,x,z]{1}[\\*,\\&]{0,1}#[0]{1}" e "#0")))
	((pscan "#[1]{1}[\\*,\\&]{0,1}#[1]{1}"     e) (eval-string-expr(preplace "#[1]{1}[\\*,\\&]{0,1}#[1]{1}"     e "#1")))
	((pscan "#[0]{1}[\\^]{1}#[0]{1}"           e) (eval-string-expr(preplace "#[0]{1}[\\^]{1}#[0]{1}"           e "#0")))
	((pscan "#[0]{1}[\\^]{1}#[1]{1}"           e) (eval-string-expr(preplace "#[0]{1}[\\^]{1}#[1]{1}"           e "#1")))
	((pscan "#[1]{1}[\\^]{1}#[0]{1}"           e) (eval-string-expr(preplace "#[1]{1}[\\^]{1}#[0]{1}"           e "#1")))
	((pscan "#[1]{1}[\\^]{1}#[1]{1}"           e) (eval-string-expr(preplace "#[1]{1}[\\^]{1}#[1]{1}"           e "#0")))
	((pscan "#[x,z]{1}[\\^]{1}#[0,1]{1}"       e) (eval-string-expr(preplace "#[x,z]{1}[\\^]{1}#[0,1]{1}"       e "#x")))
	((pscan "#[0,1]{1}[\\^]{1}#[x,z]{1}"       e) (eval-string-expr(preplace "#[0,1]{1}[\\^]{1}#[x,z]{1}"       e "#x")))
	((pscan "#[x,z]{1}[\\^]{1}#[x,z]{1}"       e) (eval-string-expr(preplace "#[x,z]{1}[\\^]{1}#[x,z]{1}"       e "#x")))
	(t e)))
(defun p<- (b b0 b1) (preplace b0 b b1))
(defun p<-* (b b0s b1s)
  (let ((r b))
	(map 'list
		 (lambda (b0 b1)
		   (setf r (p<- r b0 b1))
		   )
		 b0s
		 b1s
		 )
	r))
(defun gray-code (k) (logxor (ash k -1) k))
(defun input-permutation-string-list (bw)
  (let ((r (list)))
	(dotimes (k (expt 4 bw))
	  (let ((b "")
			(k1 k))
		(dotimes (j bw)
		  (cond
			((equalp #b00 (logand #b11 k1)) (setf b (string+"0"b)))
			((equalp #b01 (logand #b11 k1)) (setf b (string+"z"b)))
			((equalp #b10 (logand #b11 k1)) (setf b (string+"x"b)))
			((equalp #b11 (logand #b11 k1)) (setf b (string+"1"b)))
			)
		  (setf k1 (ash k1 -2))
		  )
		(push b r)
		))
	r))
(defparameter *dnf-txt* "a.dnf.txt")
(defun filt-related-pin (expr pins)
  (let ((r (list)))
	(map 'list
		 (lambda (p)
		   (if (pscan p expr)
			 (setf r (append r (list p)))))
		 pins)
	r))
(defparameter *cell_footprints* (list))
(defun analysis-dnf ()
  (format t "analysis dnf~%")
  (format t "read txt ~A~%" *liberty-txt*)
  (with-fp-w+ f *dnf-txt* 
	(format t "append txt ~A~%" *dnf-txt*)
  (let ((wc ""))
	(if (probe-file *liberty-txt*)
	  (let ()
	(setf wc (with-output-to-string (s) (exec s "wc" "-l" *liberty-txt*)))
	(setf wc (sym+(pscan "[0-9]+" wc)))
	(with-fp-r s *liberty-txt*
	  (do ((line-cnt 0 (+ line-cnt 1))
		   (line (read-line s nil 'end) (read-line s nil 'end)))
		((equalp line 'end) (format f "~%"))
		(if (pscan "(^|\\s+)(cell_footprint|pin|function|clear|clocked_on|next_state)(\\s+)(\\S+)" line)
		(let ((cell_footprint (pscan "cell_footprint(\\s+)(\\S+)" line))
			  (pin (remove-duplicates (pmatch "pin(\\s+)(\\S+)" line) :test 'equalp))
			  (expr (remove-duplicates(pmatch "(function|clear|clocked_on|next_state)(\\s+)(\\S+)" line) :test 'equalp)))
		  (if (and cell_footprint (not(member cell_footprint *cell_footprints* :test 'equalp)))
			(let ()
			  (push cell_footprint *cell_footprints*)
			  (format f "~A " cell_footprint)
			  (format t " ~4f% analysis ~A ~{~A ~} " (float(* 100 (/ line-cnt wc))) cell_footprint pin)
			  (setf pin (remove-duplicates (map 'list (lambda (p) (format f "~A " p) (preplace "\\s+" (preplace "pin(\\s+)" p " ") "")) pin) :test 'equalp))
			  (map 'list
				   (lambda (e)
					 (format f "~A " e)
					 (format t "~A " e)
					 (let ((b0 (nth 1 (psplit "\\s+" e)))
						   (cnt 0))
					   (format f "dnf ")
					   (format t "dnf ")
					   (map 'list
							(lambda (b)
							  (let ((r (eval-string-expr(p<-* b0 (filt-related-pin b0 pin) (map 'list (lambda (bi) (string+"#"bi)) (coerce b 'list))))))
								(if (equalp "#1" r) 
								  (let ()
									(format f "~A " b)
									(incf cnt)
									))
								))
							(input-permutation-string-list (length (filt-related-pin b0 pin))))
					   (format t "count ~A " cnt)
					   )
					 (let ((b0 (nth 1 (psplit "\\s+" e)))
						   (cnt 0))
					   (format f "cnf ")
					   (format t "cnf ")
					   (map 'list
							(lambda (b)
							  (let ((r (eval-string-expr(p<-* b0 (filt-related-pin b0 pin) (map 'list (lambda (bi) (string+"#"bi)) (coerce b 'list))))))
								(if (equalp "#0" r) 
								  (let ()
									(format f "~A " b)
									(incf cnt)
									))
								))
							(input-permutation-string-list (length (filt-related-pin b0 pin))))
					   (format t "count ~A " cnt)
					   )
					 )
				   expr)
			  (format f "~%")
			  (format t "~%")
			  ))
		  ))
		)))
	  (format t "can not read txt ~A ~%" *liberty-txt*)
	  )
	)))
