(defparameter *verilog-netlist-txt* "a.v.txt")
(defparameter *module-list* (list))
(defparameter *specify* nil)
(defun read-verilog-netlist (file)
  (format t "read verilog netlist ~A ~%" file)
  (if (probe-file file)
	(let ((current ""))
	  (with-fp-w+ f *verilog-netlist-txt* 
	  (with-fp-r s file 
		(do ((line (read-line s nil 'end) (read-line s nil 'end)))
		  ((equalp line 'end)
		   (let ()
			 (format f "~%")
			 (format t "~%")
			 ))
		  (let ((line1 (preplace "((([/]{1}[\\*]+)|([/]{2}))(.*)$)|(^(.*)[\\*]{1}[/]{1})" line "")))
			(if (pscan "\\S+" line1)
			  (let ()
				(setf line1 (preplace "^(\\s+)" line1 ""))
				(cond
				  ((and (not (pscan "module" current)) (pscan "^module(\\s+)" line1))
				   (let ((line2 line1)
						 (module ""))
					 (setf line2 (preplace "[\\(,\\),\\,,\\;]+" line2 " "))
					 (format f "~A" line2)
					 (setf module (nth 1 (psplit "\\s+" line2)))
					 (format t " module ~A ~%" module)
					 (if (not(member module *module-list* :test 'equalp)) (push module *module-list*))
					 (if (pscan "[\\;]+" line1)
					   (format f "~%")
					   (setf current "module")
					   )
					 ))
				  ((and (pscan "module" current) (pscan "\\S+" line1)) 
				   (let ((line2 line1))
					 (setf line2 (preplace "[\\(,\\),\\,,\\;]+" line2 " "))
					 (format f "~A" line2)
					 (if (pscan "[\\;]+" line1) 
					   (let ()
						 (setf current (preplace "module" current ""))
						 (format f "~%")
						 ))
					 ))
				  ((pscan "^endmodule" line1)
				   (let ((line2 line1))
					 (setf line2 (preplace "^(\\s+)" line2 ""))
					 (format f "~A ~%" line2)
					 ))
				  ((and (not (pscan "module" current)) (not (pscan "specify" current)) (pscan "^(input|output|inout)(\\s+)" line1))
				   (let ((line2 line1))
					 (setf line2 (preplace "[\\,,\\;]+" line2 " "))
					 (format f " ~A" line2)
					 (if (pscan "[\\;]+" line1)
					   (let ()
						 (format f " ~%")
						 ))
					 ))
				  ((and *specify* (not (pscan "specify" current)) (pscan "^specify" line1))
				   (let ()
					 (format f " ~A ~%" line1)
					 (setf current "specify")
					 ))
				  ((and *specify* (pscan "specify" current) (not (pscan "^endspecify" line1)) (pscan "\\S+" line1))
				   (let ((line2 line1))
					 (setf line2 (preplace "[\\(,\\),\\,,\\;,\\=]+" line2 " "))
					 (setf line2 (preplace "^(\\s+)" line2 ""))
					 (format f "  ~A ~%" line2)
					 ))
				  ((and *specify* (pscan "specify" current) (pscan "^endspecify" line1))
				   (let ()
					 (format f " ~A ~%" line1)
					 (setf current (preplace "specify" current ""))
					 ))
				  ((and (not (pscan "specify" current)) (not (pscan "instance" current)) (pscan "^([0-9,a-z,A-Z,_]+)(\\s+)" line1))
				   (let ((line2 line1))
					 (setf line2 (preplace "(^|[\\s,\\(,\\),\\,])+[\\.]{1}" line2 " "))
					 (setf line2 (preplace "[\\(,\\),\\,,\\;,\\=]+" line2 " "))
					 (setf line2 (preplace "^(\\s+)" line2 ""))
					 (format f " ~A" line2)
					 (if (pscan "[\\;]+" line1)
					   (format f " ~%")
					   (setf current "instance")
					   )
					 ))
				  ((and (not (pscan "specify" current)) (pscan "instance" current) (pscan "\\S+" line1))
				   (let ((line2 line1))
					 (setf line2 (preplace "(^|[\\s,\\(,\\),\\,])+[\\.]{1}" line2 " "))
					 (setf line2 (preplace "[\\#,\\(,\\),\\,,\\;,\\=]+" line2 " "))
					 (setf line2 (preplace "^(\\s+)" line2 ""))
					 (format f " ~A" line2)
					 (if (pscan "[\\;]+" line1)
					   (let ()
						 (setf current (preplace "instance" current ""))
						 (format f " ~%")
						 )
					   )
					 ))
				  )
				)))
		  )))
	  )
	(format t "can not read verilog netlist ~A~%" file))
  )
(defun write-verilog-netlist-1 (file top)
  ;(format t "~S~%" top)
  (if (probe-file *verilog-netlist-txt*)
	(with-fp-w+ f file
	(with-fp-r s *verilog-netlist-txt* 
	  (let ((current ""))
		(do ((line (read-line s nil 'end) (read-line s nil 'end)))
		  ((equalp line 'end)
		   (let ()
			 (format f "~%")
			 ))
		  (if (pscan "\\S+" line)
			(let ((line1 line))
			  (cond
				((and (not(pscan "specify" current)) (pscan (string+"^module(\\s+)"top"(\\s+)") line1))
				 (let ((line2 (psplit "\\s+" line1)))
				   (format f "module ~A (~{~A~^, ~});~%" (nth 1 line2) (cddr line2))
				   (setf current (string+ current"module"))
				   ;(format t " module ~A ~%" top)
				   ))
				((and (not(pscan "specify" current)) (pscan "module" current) (pscan "^([\\s]{1})(\\S+)" line1))
				 (let ((line2 line1))
				   (setf line2 (preplace "^(\\s+)" line2 ""))
				   (setf line2 (psplit "\\s+" line2))
				   (cond
					 ((pscan "(input|output|inout|wire|reg)" (nth 0 line2))
					  (let ()
						(cond
						  ((pscan "^([\\[]{1})" (nth 1 line2))
						   (let ()
							 (format f " ~A ~A ~{~A~^, ~};~%" (nth 0 line2) (nth 1 line2) (cddr line2))
							 ))
						  (t (let ()
							   (format f " ~A ~{~A~^, ~};~%" (nth 0 line2) (cdr line2))
							   ))
						  )
						))
					 ((pscan "assign" (nth 0 line2))
					  (let ()
						(format f " assign ~A = ~A; ~%" (nth 1 line2) (nth 2 line2))
						))
					 ((and (evenp(length line2)) (> (length line2) 2))
					  (let ()
						(format f " ~A ~A ( .~A(~A) " (nth 0 line2) (nth 1 line2) (nth 2 line2) (nth 3 line2))
						(do ((k 4 (+ k 1)))
						  ((>= k (length line2)))
						  (if (evenp k)
							(format f ", .~A" (nth k line2))
							(format f "(~A) " (nth k line2))
							)
						  )
						(format f ");~%")
						))
					 )
				   ))
				((and (not(pscan "specify" current)) (pscan "module" current) (pscan "^endmodule" line1))
				 (let ()
				   (format f "endmodule~%")
				   (format t " write module ~A ~%" top)
				   (setf current (preplace "module" current ""))
				   ))
				)
			  ))
		  ))))
	(format t "can not read verilog netlist txt ~A ~%" *verilog-netlist-txt*)))
(defparameter *verilog-netlist-txt-hierarchy* (list))
(defun verilog-netlist-txt-hierarchy (top)
  (push top *verilog-netlist-txt-hierarchy*)
  (if (probe-file *verilog-netlist-txt*)
	(let ((current ""))
	  (with-fp-r 
		s *verilog-netlist-txt*
		(do ((line (read-line s nil 'end) (read-line s nil 'end)))
		  ((equalp line 'end))
		  (if (pscan "\\S+" line)
			(let ((line1 line))
			  ;(format t "~S~%" line1)
			  (cond
				((and (not(pscan "module" current)) (pscan (string+"^module(\\s+)"top"(\\s+)") line1))
				 (let ()
				   (setf current (string+ current"module"))
				   ))
				((and (pscan "module" current) (pscan "^endmodule" line1))
				 (let ()
				   (setf current (preplace "module" current ""))
				   ))
				((and (pscan "module" current) (pscan "^([\\s]{1})" line1))
				 (let ((line2 line1))
				   (setf line2 (preplace "^(\\s+)" line2 ""))
				   (setf line2 (psplit "\\s+" line2))
				   (cond
					 ((member (nth 0 line2) *module-list* :test 'equalp)
					  (let ((module (nth 0 line2)))
						(if (not(member module *verilog-netlist-txt-hierarchy* :test 'equalp)) 
						  (let ()
							;(push module *verilog-netlist-txt-hierarchy*)
							(verilog-netlist-txt-hierarchy module)
							))
						))
					 )
				   ))
				)
			  ))))
	  top)
	nil))
(defun write-verilog-netlist (file top &key hierarchy)
  (format t "write verilog netlist ~A with top ~A ~%" file top)
  (if hierarchy
	(let ()
	  (setf *verilog-netlist-txt-hierarchy* (list))
	  (verilog-netlist-txt-hierarchy top)
	  (setf *verilog-netlist-txt-hierarchy* (remove-duplicates *verilog-netlist-txt-hierarchy* :test 'equalp))
	  ;(format t "~S~%" *verilog-netlist-txt-hierarchy*)
	  (map 'list
		   (lambda (u)
			 (write-verilog-netlist-1 file u)
			 )
		   *verilog-netlist-txt-hierarchy*)
	  )
	(write-verilog-netlist-1 file top)
	)
  )
